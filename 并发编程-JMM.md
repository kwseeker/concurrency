[TOC]

基础：

1）Java指令集



## 1 Java内存模型概述

内存模型描述了线程间通过内存和共享数据的交互。

为什么需要定义Java内存模型？为了屏蔽不同的处理器架构上内存模型的差异，以及封装CPU缓存和指令重排的操作复杂性，需要用内存模型定义操作流程，决定线程什么时候可以读取其他线程写的数据，保证数据一致性。

Java内存模型是通过各种操作来定义的，包括对变量的读写操作，监视器的加锁和释放操作，以及线程的启动和合并操作。JMM为程序中所有的操作定义了一个偏序关系（happen-before）。

+ **代码从编译到执行**

  

+ **CPU缓存与缓存一致性**

  主流CPU缓存架构：

  一级缓存（每个CPU核心独有） -> 二级缓存（每个CPU核心独有） -> 三级缓存（所有核心共享） -> 主内存

  一二级缓存又被称为线程本地缓存。

  多线程多核心处理，一个共享的对象在一二级缓存上会有多个副本，由此带来缓存一致性的问题。 

  保证CPU缓存一致性：

  + **Lock总线**

    加锁机制，共享对象只能在一个CPU核心上被使用，不允许同时出现在多个CPU核心的缓存中，性能低下。

  + **缓存一致性协议MESI**

    现在多用MESI保证缓存一致性，共享对象允许在多个CPU核心的缓存上存在，拥有四种状态：Shared、Exclusive、Modified、Invalid。

    ![MESI状态迁移](http://imgedu.lagou.com/d98244d3850e4721b27cfdbee89c34ae.jpg)

    ![](https://img-blog.csdn.net/20180531185023380?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDMyNTU5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

+ **指令重排**

  为了提升性能，代码执行从编译到执行，指令可能会先后被编译器、CPU、内存系统重排序。

  源代码 -> 编译器优化重排序 -> 指令级并行重排序 -> 内存系统重排序 -> 最终执行的指令序列

+ **缓存一致性模型**

  + **顺序一致性语义**

    Lamport提出的操作规范：

    R1: 一个线程内的所有操作必须按照程序的顺序来执行。

    R2: 所有线程都只能看到相同的操作执行视图（是否同步）。

    这种规范不允许指令重排优化，执行效率不高。

  - **happen-before（JMM采用的方式）**

    happen-before八大规则：参考《Java并发编程实战》Chapter16。

    如何理解这些规则？

    首先这些规则不是

    包含两个基本的定义：a.如果A操作在B操作之前执行，则A操作结果对B操作可见; b.两个操作之间存在happen-before关系，不一定按代码顺序执行，即可能发生重排序，但是重排序后执行结果与排序之前执行结果必定相同。

    1）程序顺序规则

    2）监视器锁规则

    3）volatile变量规则

    如果对volatile变量的写在对该变量的读之前执行，则写操作结果对读可见。

    然后再理解下下面测试案例的结果。
    
    ```java
    //为何出现下面结果
    int x, y;					//(0,0) (0,1) (1,0) (1,1)
    volatile int x, int y;		//(0,0) (0,1) (1,0) (1,1)
    volatile int x, y;			//(0,1) (1,0) (1,1)
    Thread1:
    	x=1;
    	println(y);
    Thread2：
    	y=1;
    	println(x);
    ```
    
    4）线程启动规则
    
    5）线程结束规则
    
    6）中断规则
    
    7）终结器规则
    
    8）传递性
    
    happen-before更多的是说限制重排序以及操作可见性。
    
    拥有happen-before关系的两个操作不能重排序。
    
    具有happen-before关系的两个操作，前一个操作的结果对后一个操作可见。
    
    

## 2 Java内存划分与使用

对象的基本类型成员、类成员、方法、方法内的变量都是存储在哪个内存空间？多线程会共享哪些内存空间？



## 3 多线程哪些内容是共享的

为什么对象的方法内的变量不是多线程共享的？



## 4 测试案例

#### 4.1 下面一段程序可能的执行结果

```java
int x=0, y=0;
Thread1: y=1;println(x);
Thread2: x=1;println(y);
```



## 附录 

在学习 JVM 后再反复看看内存模型。

参考资料：

《计算机体系结构：量化研究方法》亨尼西

[Java Memory Model Under The Hood](https://gvsmirnov.ru/blog/tech/2014/02/10/jmm-under-the-hood.html)

