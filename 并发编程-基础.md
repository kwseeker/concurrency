[TOC]

## 1 并发概念

个人认为并发是基于CPU时间片和OS任务调度;并行基于CPU多处理核心;编程中的并发是广义的往往包含并行的概念。

+ **为何要用并发？**

  其实只有一个目的充分利用CPU资源，有人说还为了实现异步，异步不就是把一个任务拆分成多个可以同时执行的组件参与空闲的时间片竞争并执行么。

  充分利用CPU资源、更快地处理速度、实现异步（异步是充分使用CPU资源的另一种表述，而更快的处理速度是充分利用CPU资源的结果）。

  吐槽：总是有很多人把一个东西从不同角度說一边，然后堆起来，还不讲清关系，让人理解起来乱糟糟的。

+ **如何将CPU的多核心充分应用起来？**

  个人任务只能优化软件底层实现了，比如研发新语言，如Go语言，它天然支持高并发多线程是因为它优化了线程上下文切换（自己有协程调度管理器）和线程资源（开启一个协程只需要2K的内存）开销。

+ **并发涉及哪些基本概念？**

  threads、locks、condition queues、thread pool、blocking queues、concurrent collections、fork-join、 parallel streams 等等。



## 2 并发编程带来的风险

+ **安全性问题**

  - 竞态条件 与 原子性

    案例：

    a. 先检查后执行，比如先查询用户账户余额再扣款。

    b. 延迟初始化，比如典型的单例模式。

    原子性，字面是不可分割，原子操作指对同一个状态的多个线程的相同操作，其中某一个线程的操作对其他线程而言都是不可被中断的，其他线程操作这个状态必须在这个线程之前或之后。

+ **活跃性问题**

  - 死锁

  - 活锁

  - 饥饿

  - 无锁

    没有对资源进行锁定，即所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。

+ **性能问题**

  为什么硬件上可以将处理器核心堆到很多，但是软件确用不起来？因为同时引入了下面这些问题。当线程数量增加到一定值时，任务处理速度不升反降。

  - 频繁的上下文切换

  - 线程同步开销

  - 线程本身的开销



## 3 并发问题解决

#### 3.1 竞态条件

 + **加锁解决**（阻塞同步方式）

   加锁可以将被锁的操作变成原子操作。

   - 内置锁（又称监视器锁） synchronized

     是一种可重入互斥锁，

     可重入指获取锁的操作的粒度是“线程”，而不是”调用“。

     可重入的一种实现原理：锁关联一个计数器和所有者线程，当锁计数器值为0,锁可被线程获取，获取锁的线程重复获取锁，计数值会递增，反之，计数值递减，当计数值为0锁将被释放。

     加锁规范：

     1）一种常见的方式是将所有的可变状态都封装到对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，很多线程安全类都是使用这种模式。

     2）尽量缩小加锁粒度（将不需要同步的部分从同步代码块中分离出去）。

     3）执行时间较长的操作（网络IO、控制台IO）一定不要持有锁。

   互斥锁的优化：乐观锁（引入失败重试，通过补偿措施避免一味地对竞态条件进行加锁）。

+ **非阻塞同步方式解决**

  非阻塞同步机制基于原子机器指令，可以基于原子变量类构建高效的非阻塞算法。不存在死锁和活跃性问题，在中低程度竞争下性能损耗低，但是高竞争程度，。

  - 比较并交换（CAS，硬件实现提供机器指令，类似于数据库的乐观锁实现->版本控制，所以也是适合读多写少情况）

    如果一个线程准备执行更新时，另一个线程在最近一次检查更新了该变量，CAS可以检测到这个错误。

    然后线程不会挂起，而是被告知在这次竞争中失败，可以再次尝试。

  - 关联加载/条件存储（Load-Linked/Store-Conditional，硬件实现提供机器指令）

  - 原子变量类（基于CAS）

+ **回避产生竞态条件**

  不是在竞态条件后再同步而是不共享数据，通过为每个线程创建一个副本，仅在单个线程中访问副本数据（线程封闭），Swing大量使用了线程封闭，JDBC连接也使用了这种技术。

  线程封闭：

  - Ad-hoc线程封闭

    维护线程封闭性的职责全部由程序实现来承担。

  - 栈封闭（局部变量）

  - ThreadLocal类

+ **正确地共享和发布对象**

  ”发布“：使对象能够在当前作用域之外的代码中使用。

  ```java
  //1) 将对象的引用存入公有静态变量
  public static Set<Secret> knownSecrets;
  public void initialize() {
  	knownSecrets = new HashSet<>;
  }
  //2) 通过public方法返回
  public Secret someMethod() {...}
  //3) 将引用传入其他类的方法
  someClass.someMethod(secret);
  ```

  即如何构建线程安全类，安全发布对象，以及通过JUC构建并发应用程序。

  安全发布对象的几种方式：

  - 在静态初始化函数中初始化一个对象引用

  - 将对象的引用保存在volatile类型的域或者AtomicReference对象中

    实例参考《Java并发编程实战》构造非阻塞栈。

  - 将对象的引用保存到某个正确构造对象的final类型域中

  - 将对象的引用保存到一个由锁保护的域中

+ **设计线程安全的类**

  为了不每次对内存访问时都分析程序代码以确保程序是线程安全的，就需要将现有的类都设计成线程安全的组件（操作方法都是线程安全的），然后使用他们组合成更大规模的组件或程序。

  

#### 3.2 并发编程3大特性

- **原子性**

  参考第2节[安全性问题]分析。

  确保原子性的手段：

  1）使用同步机制：锁

- **有序性**

- **可见性**

  可见性即对竞态资源的写操作的结果总是可以被后续的读操作读取到。

  确保可见性的手段：

  1）使用同步机制：锁

  2）volatile，不会将该变量的操作与其他内存操作一起重排序，volatile变量不会被缓存在寄存器或CPU核心私有缓存上（volatile不会使用CPU核心一二级缓存）。

  ​	volatile仅当能简化代码的实现以及对同步策略进行验证时才应该使用。

  ​	volatile通常用作某个操作完成、发生中断、或者标识状态的标志。

  ​	volatile使用场景：

  ​	a) 对变量的写入操作不依赖变量的当前值，或者能确保只有单个线程更新变量的值。

  ​	b) 该变量不会与其他状态变量一起纳入不变性条件中。 

  ​	c) 在访问变量时不需要加锁。
  
  > volatile语义：
  >
  > 1）可见性（也是happen-before的volatile变量规则），volatile变量的读总能看到对这个volatile变量的最后写入;
  >
  > 2）原子性，单个volatile变量的读写操作具有原子性，复合操作没有原子性;
  >
  > volatile操作会被JMM限制重排序: 
  >
  > ![](https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwODA5MDY0MTExNDgz?x-oss-process=image/format,png)



## 3 进程和线程

+ **两者区别**

+ **线程概念**

  - 线程安全

    定义：（自定义）多线程操作同一个共享对象不做同步，不管怎么操作，每一步操作完成后结果都是固定的符合期望的。

    线程共享对象中哪些内容不做同步会有线程安全问题？

## 4 遗留问题

为何当线程数量增加到一定值时，任务处理速度不升反降？何时会发生进程、线程上下文切换？切换过程涉及哪些系统资源？

进程和线程反映到内存、寄存器上是什么样子的？

还有很多问题只知道概念，不清楚实现原理，要理解明白需要深入到编译器原理，操作系统内核。

《Java并发编程实战》中提到的定期对数据处理进度生成快照，当程序崩溃或停止时，从上个快照进行恢复是怎么实现的？

load-store是那部分提供的功能？

JVM -server命令行选项 启动 server模式？

CAS，一个线程比较后更新前为什么可以怎么检测到的值已经被其他线程更新了的？

