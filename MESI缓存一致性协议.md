

# MESI 缓存一致性协议

CPU 和 主存的读写速度差距很大，为了弥补这种差距，在CPU和主存之间增加了多层高速缓存。

高速缓存是集成在 CPU 核心上的，即每个 CPU 核心都有自己的高速缓存。

但是引入高速缓存后就带来了缓存一致性问题。

解决缓存一致性的方案有两种：

+ 总线上加锁

  总线被锁期间其他CPU无法访问内存，性能低下。

+ 缓存一致性协议

  最出名的是  Intel MESI 协议。这是硬件层面上的缓存一致性协议实现。

**MESI 协议中定义了缓存行的四种状态**:

+ M(Modified)：这行数据（缓存行）有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中 
+ E(Exclusive)：这行数据有效，数据和内存中的数据一致，数据只存在于本Cache中 
+ S(Shared)：这行数据有效，数据和内存中的数据一致，数据存在于很多Cache中 
+ I(Invalid)：这行数据无效

**MESI 核心思想**：

当某个CPU修改缓存行后（本地缓存行变为 M 状态），需要通知其他CPU将同一共享变量所在缓存行修改为 I 状态，当修改的数据成功写会主存后，本地缓存行变为 E 状态，其他CPU通过嗅探机制发现修改的数据已经成功写回主内存，会重新从内存中加载最新的值，所有CPU 此共享变量所在缓存行状态再次变更为 S 状态，然后各CPU都可以继续竞争写。

> 详细状态转换可以参考：[缓存一致性协议（MESI）](https://www.cnblogs.com/ynyhl/articles/12119690.html)

其中一个CPU缓存行状态的改变通知给其他CPU是通过总线嗅探机制实现的。

总线嗅探是多处理器系统中的一种通信机制，用于处理多个处理器共享的数据。在这种机制下，每个处理器都可以监视系统总线上的数据传输，以便了解数据是否与自己相关 如果数据与某个处理器相关，则该处理器将接管该数据，进行相应的操作。总线嗅探机制能够提高系统的性能，因为它能够减少数据冲突和锁竞争等问题,提高系统的并行性和效率。

但是，如果多个线程频繁地读写共享变量，就会导致大量的总线通信，从而引发总线风暴的问题，降低系统的性能。

**MESI 为何不能保证线程安全**？

以两个线程同时对 a 进行 +1 操作为例，推测流程如下：

> 没有找到资料说明，纯属于个人推测。

1. 初始状态：
   主内存：a = 0
   T1 缓存：a = 0，状态为 S
   T2 缓存：a = 0，状态为 S
2. T1 读取 a 的值：
   T1 缓存：a = 0，状态为 S
3. T2 读取 a 的值：
   T2 缓存：a = 0，状态为 S
4. T1 准备修改 a：
   T1 发送请求，要求将 a 的缓存行状态从 S 转换为 E（独占）
   T2 收到请求，将 a 的缓存行状态设置为 I（无效）
   T1 缓存：a = 0，状态为 E
5. T1 将 a 加一：
   T1 缓存：a = 1，状态为 M（已修改）
6. T2 准备修改 a：
   T2 发送请求，要求将 a 的缓存行状态从 I 转换为 E
   **T1 收到请求，将 a 的缓存行状态设置为 I，并将最新值 a = 1 写回主内存**   **//这次写是MESI协议要求**
   T2 缓存：a = 1，状态为 E
7. T2 将 a 加一：
   T2 缓存：a = 2，状态为 M
8. T2 写回 a 的值：
   T2 缓存：a = 2，状态为 M
   主内存：a = 2
9. **T1 写回 a 的值**：                          **//这次写是指令要求**
   T1 缓存：a = 1，状态为 M
   主内存：a = 1

最终结果是 a = 1，而不是预期的 a = 2。